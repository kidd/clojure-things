#+TITLE: Clojure things I learn
#+AUTHOR: Raimon Grau
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:nil arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:nil
#+OPTIONS: e:t email:nil f:t inline:t p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t todo:t |:t
#+EXCLUDE_TAGS: noexport
#+KEYWORDS: bash zsh shell
#+LANGUAGE: en
#+SELECT_TAGS: export

#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

#+OPTIONS: reveal_center:nil timestamp:nil
#+REVEAL_THEME: black

# toc:nil num:nil
* clojure
** start an app
*** lein
    =lein new app foo=
    =lein repl=
    =lein run=
*** deps.edn
*** cljs
    #+begin_src bash
    lein new re-frame foobar +10x
    edit shadow-cljs.edn add lib
    npx shadow-cljs watch app
    cider-connect-cljs local 7888 shadow-select :app .
    #+end_src

** deps.edn
   - http://www.futurile.net/2020/03/07/clojure-lein-dev-experience-and-repl-tools/
   - https://www.manueluberti.eu/programming/2018/11/14/deps-shadow-cljs/
** tutorials
    - cljs re-frame: https://www.youtube.com/user/VideosDanA
    - spa re-frame: https://www.youtube.com/watch?v=yVb8PS6a4Mk&t=666s
    - TODO in cljs https://www.youtube.com/watch?v=jAkw6Wb-rTA
    - integrant: https://www.youtube.com/playlist?list=PLb5SjnGEsSJdJnbjxVWci1P7mKY-K1ExD
** shadow-cljs
   https://jiyinyiyong.medium.com/a-beginner-guide-to-compile-clojurescript-with-shadow-cljs-26369190b786
   Shadow-cljs is a tool, like make, or denom. Or lein. That builds
   packages. Like lein it does the building of the pipeline, but
   unlike lein, it also has the hot reload thing. So it's like
   lein+repl-with-hotreload.

   Figwheel and figwheel-main are alternatives to it, but they are
   basically substitutes one for the other.

   Clojurescript has shitloads of repls,
   https://lambdaisland.com/guides/clojure-repls/clojurescript-repls#org8300646
   .At this point, I dont' know if shadow-cljs provides its own repl
   mechanism, or it's on you to say "shadow-cljs, I want you to use
   rhino as a repl".
   https://clojureverse.org/t/what-is-the-difference-between-figwheel-main-and-figwheel-sidecar/6832
** etaoin
   selenium-like. just from clojure/babashka.
** string to uuid in postgres pg
   #+begin_src clojure
     (ns foo.bar
      (:import java.util.UUID))
     (tdb/update-where! 'Product {:id id} :user-id (java.util.UUID/fromString new-window-id)))

   #+end_src
** add libs live
   To add libraries live you need the combination of 3 things:
   - lein
   - clj-commons/pomegranate
   - https://www.eigenbahn.com/2020/05/06/fast-clojure-deps-auto-reload
   - https://github.com/clj-commons/pomegranate
   - https://github.com/clojure/tools.trace
   - https://github.com/philoskim/debux
   - https://eli.thegreenplace.net/2017/notes-on-debugging-clojure-code/
   - https://cognitect.com/blog/2017/6/5/repl-debugging-no-stacktrace-required
** indentation
   :PROPERTIES:
   :CUSTOM_ID: 2d3b5ab6-8c01-46fd-9443-e21f25a2af8c
   :END:
   - https://github.com/kkinnear/zprint
   - clj-rewrite
   - babashka stuff?
** lein test
   :PROPERTIES:
   :CUSTOM_ID: 2134230d-d0a7-430f-bff1-9f301a2306b1
   :END:
   lein test :only my.namespace/my-test
   lein test :only my.namespace
** unalias
   :PROPERTIES:
   :CUSTOM_ID: e864f2cc-92b1-4c6b-ab13-c52457774398
   :END:
   (ns-unalias *ns* 't)
** socket repl
   #+begin_src bash
     java -Dclojure.server.repl={:port 6666 :accept clojure.core.server/repl} -jar target/uberjar/myuberjar.jar
     #notice in project.clj there's a :socket profile as well that i use for local dev
   #+end_src
** clojure by example
   https://news.ycombinator.com/item?id=27273911
** add conditionally to a map
  (merge base-map
     (when name
        {:name name}
     (when address
        {:address address})

  similar to CL's `(:a 1 ,@(when foo `(:b 2)))
** subsets
   A set is a map with values equal to keys.

   Creating a map from a set is trivial, you get {:a :a, :b :b ....}

   maps can be converted to sets, and the elements are vectors of [k v]
   #+begin_src clojure
     (set [1 2])                               ; #{1 2}
     (set {:a 1})                              ; #{[:a 1]}
     (set {:a 1})                              ; #{[:a 1]}
     (set/subset? (set {:a 1}) (set {:a 1}))   ; true
     (set/subset? (set {:a 1}) (set {:a 2}))   ; false
     (set/subset? (set {:a 1}) (set [:a 1]))   ; false
     (set/subset? (set {:a 1}) (set [:a 1]))   ; false
     (set [:a 1])                              ; #{1 :a}
     (set [:a :a])                             ; #{:a}
     (set [[:a 1]])                            ; #{[:a 1]}
     (set/subset? (set {:a 1}) (set [:a 1]))   ; false
     (set/subset? (set {:a 1}) (set [[:a 1]])) ; true
     (set {1 :a})                              ; #{[1 :a]}
     (into {} (set {:a 1}))                   ; {:a 1}
   #+end_src

   Even thought there might be a way to create a hash from a set like
   this =(fun #{:a}) ; => {:a :a}= that would mean that you can
   prepare a set and a hash that would be "equal", but from what I see
   above, conversions between maps and sets work neatly.

   #+begin_src clojure
     (set/subset? (set {:a 1}) #{:a})
     (set/subset? #{:a}        (set {:a 1}) )
     (set/subset? #{:a}        (set [:a]) )
     (set/subset? (set [:a])   #{:a})
     (set/subset? (set [:a])   #{:a})
     ...
     (set/subset? (set {:a 1}) (set [[:a 1]])); true
     (set/subset? (set {:a 1}) (set [:a 1])); false
     {:a 1} (into {} [[:a 1]]); {:a 1}{:a 1}
   #+end_src
** Where did I leave that stuff?
   So, I'm debugging something, and I use the inspector to retain some value I want for later.
   =d myvar= will save that value as =myvar= in the current namespace you're in.

   Later on, you move namespace and you want to get back that =myvar=
   but you don't remember where it was stored.

   =cider-apropos myvar= will list you which ns have this defined. so
   you can go and fetch it from there.
